#!/usr/bin/env python
'''
Prepare initial conditions for the orbit loss calculation
'''
import numpy as np
from booz_xform import Booz_xform
from simsopt.field.boozermagneticfield import BoozerRadialInterpolant
from simsopt.util.constants import (
        ALPHA_PARTICLE_MASS as MASS,
        FUSION_ALPHA_PARTICLE_ENERGY as ENERGY
        )

def estimate_max_J(field : BoozerRadialInterpolant):
    '''
    Approximates maximum value of Boozer Jacobian
    by a maximum value on a sampled grid
    '''
    s_grid = np.linspace(0, 1, 100)
    theta_grid = np.linspace(0, 2 * np.pi, 100, endpoint=False)
    zeta_grid = np.linspace(0, 2 * np.pi, 100, endpoint=False)
    [zeta_grid,theta_grid,s_grid] = np.meshgrid(zeta_grid,theta_grid,s_grid)
    points = np.zeros((len(s_grid.flatten()),3))
    points[:,0] = s_grid.flatten()
    points[:,1] = theta_grid.flatten()
    points[:,2] = zeta_grid.flatten()
    field.set_points(points)
    G = field.G()
    iota = field.iota()
    I = field.I()
    modB = field.modB()
    J = (G + iota * I) / (modB**2)
    return np.max(J)

def reactivity(s : float):
    '''
    Computes normalized reactivity of
    alpha particles creation, in Boozer coordinates.
    '''
    T0_keV = 11.5
    max_sigma = T0_keV**(-2/3) * np.exp(-19.94 * T0_keV**(-1/3))
    T = T0_keV * (1 - s)
    n = 1 - s**5
    return n * n * T**(-2/3) * np.exp(-19.94 * T**(-1/3)) / max_sigma

def generate(
        n_particles,
        reactivity,
        field,
        nfp,
        min_s=0.0,
        max_s=1.0,
        save=True,
        random_seed = 0
        ):
    '''
    Generates `n_particles` positions of alpha particles
    in equilibrium `field`, sampled from the distriution
    that corresponds to `reactivity` (in Boozer coordinates)
    fusion production rate of alpha particles
    '''
    np.random.seed(random_seed)
    max_J = estimate_max_J(field)
    s_init = []
    theta_init = []
    zeta_init = []
    for i in range(n_particles):
        while True:
            s = np.random.uniform(min_s, max_s, None)
            theta = np.random.uniform(0, 2 * np.pi, None)
            zeta = np.random.uniform(0, 2 * np.pi / nfp, None)
            field.set_points(np.column_stack((s, theta, zeta)))
            normalized_J = (
                (field.G()[0,0] + field.iota()[0,0]*field.I()[0,0])
                / (field.modB()[0,0]**2) / max_J
                )
            reactivity_per_volume = reactivity(s) * normalized_J
            if (np.random.uniform(0, 1, None) <= reactivity_per_volume):
                print(f'Particle sample {i} with {s=}')
                s_init.append(s)
                theta_init.append(theta)
                zeta_init.append(zeta)
                break
    VELOCITY = np.sqrt(2 * ENERGY / MASS)
    vpar_init = np.random.uniform(-VELOCITY, VELOCITY, (n_particles,))
    points = np.zeros((n_particles, 3))
    points[:,0] = np.array(s_init)
    points[:,1] = np.array(theta_init)
    points[:,2] = np.array(zeta_init)
    field.set_points(points)
    mu_per_mass = (VELOCITY**2 - vpar_init**2) / (2 * field.modB()[:,0])

    if save:
        np.savetxt('s0.txt', s_init)
        np.savetxt('theta0.txt', theta_init)
        np.savetxt('zeta0.txt', zeta_init)
        np.savetxt('vpar0.txt', vpar_init)
        np.savetxt('mu_per_mass.txt', mu_per_mass)
    return {
        's0' : s_init,
        'theta0' : theta_init,
        'zeta0' : zeta_init,
        'vpar0' : vpar_init,
        'mu_per_mass' : mu_per_mass
    }

def check_energy(initial_conditions, field):
    '''
    Check that initial conditions for alpha particles in `field`,
    generated by `generate` above, have fusion product energy
    '''
    s0 = initial_conditions['s0']
    theta0 = initial_conditions['theta0']
    zeta0 = initial_conditions['zeta0']
    mu_per_mass = initial_conditions['mu_per_mass']
    vpar0 = initial_conditions['vpar0']
    max_energy_error = 0.0
    for i in range(len(s0)):
        field.set_points(np.column_stack((s0[i], theta0[i], zeta0[i])))
        energy = MASS * (
                vpar0[i]**2 / 2
                + mu_per_mass[i] * field.modB()[0,0]
                )
        print(
            f'#{i} particle {energy=}',
            f'     fusion {ENERGY=}',
            sep='\n'
            )
        assert np.isclose(energy,ENERGY), f'Particle #{i} has wrong energy'
        energy_error = np.abs(np.max(energy - ENERGY))
        if energy_error > max_energy_error:
            max_energy_error = energy_error
    print(
        f'{max_energy_error=} Joules,',
        f'which is {max_energy_error/ENERGY} of fusion born alpha energy',
        sep='\n'
        )

if __name__ == '__main__':

    number_of_particles = 5000
    boozmn_file = '../boozmn_qhb_100.nc'
    equil_helicity = -4 # Check that this matches boozmn_file!

    print('Attempt to generate initial condition,',
          f'\t{number_of_particles=}',
          f'\tBoozer coordinates equilibrium datafile {boozmn_file=}',
          f'\tAssumed helicity of the equilibrium {equil_helicity=}',
          sep = '\n'
        )

    print('Loading equilibrium...')
    equil = Booz_xform()
    equil.verbose = False
    equil.read_boozmn(boozmn_file)
    nfp = equil.nfp

    bri = BoozerRadialInterpolant(
        equil=equil,
        order=3,
        N=equil_helicity,
        no_K=True # because K is no yet used in tracing
        )

    input('press ENTER to continue')
    print('Generating initial conditions (ICs):')
    ic = generate(
        n_particles=number_of_particles,
        reactivity=reactivity,
        field=bri,
        nfp=nfp,
        min_s=0.1,
        max_s=0.85,
        save=True,
        random_seed=0
        )

    print('Checking generated ICs...')
    check_energy(ic, field=bri)
    print('Done.')
